/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */

use clap::{App, Arg};
use filetime::{set_file_times, FileTime};
use plist::Value;

use std::collections::HashMap;
use std::fs;
use std::path::{Path, PathBuf};

struct Album {
    album_name: String,
    images: Vec<u32>,
}

struct Master {
    path: PathBuf,
    timestamp: FileTime,
}

fn album_from_value(value: &plist::Value) -> Album {
    let dict = value.as_dictionary().unwrap();
    Album {
        album_name: dict
            .get("AlbumName")
            .unwrap()
            .as_string()
            .unwrap()
            .replace("/", "")
            .trim()
            .to_string(),
        images: dict
            .get("KeyList")
            .unwrap()
            .as_array()
            .unwrap()
            .into_iter()
            .map(|key| key.as_string().unwrap().to_string().parse::<u32>().unwrap())
            .collect(),
    }
}

fn albums_from_value(value: &plist::Value) -> Vec<Album> {
    let data = value.as_array().unwrap();
    data.into_iter()
        .map(|album| album_from_value(album))
        .collect()
}

fn masters_from_value(
    value: &plist::Value,
    archive_path: &str,
    base_path: &Path,
) -> HashMap<u32, Master> {
    let mut masters = HashMap::new();
    let data = value.as_dictionary().unwrap();
    for (key, value) in data.into_iter() {
        let index = key.to_string().parse::<u32>().unwrap();
        let path = value
            .as_dictionary()
            .and_then(|dict| dict.get("ImagePath"))
            .and_then(|path| path.as_string())
            .map(|path| path.replace(archive_path, "."))
            .map(|rpath| base_path.join(rpath))
            .unwrap();
        let timestamp = value
            .as_dictionary()
            .and_then(|dict| dict.get("DateAsTimerIntervalGMT"))
            .and_then(|interval| interval.as_real())
            .unwrap();
        masters.insert(
            index,
            Master {
                path: path,
                // Apple CoreData's epoch is not the Unix epoch
                timestamp: FileTime::from_unix_time((timestamp + 978307200.0) as i64, 0),
            },
        );
    }
    masters
}

// I would use serde_derive to deserialize the archive, but Apple doesn't stick to the same
// key naming convention and I'm not sure how to get serde to deal with that.
fn main() -> Result<(), std::io::Error> {
    // Parse command line options
    let matches = App::new("iphoto-extract")
        .version(env!("CARGO_PKG_VERSION"))
        .author(env!("CARGO_PKG_AUTHORS"))
        .about("Converts an Apple iPhoto library into an album directory structure")
        .arg(
            Arg::with_name("library-path")
                .short("l")
                .long("library-path")
                .value_name("LIBRARY")
                .help("Path to the iPhoto Library")
                .takes_value(true),
        )
        .arg(
            Arg::with_name("output-path")
                .short("o")
                .long("output-path")
                .value_name("OUTPUT")
                .help("Path where the extracted albums will be placed")
                .takes_value(true),
        )
        .get_matches();

    // Create the output directory
    let mut output_path = PathBuf::from(matches.value_of("output-path").unwrap_or("extract"));
    fs::create_dir(output_path.as_path())?;

    // Read Library plist structure
    let mut library_path = match matches.value_of("library-path") {
        Some(path) => PathBuf::from(path),
        None => std::env::current_dir().unwrap(),
    };

    library_path.push("AlbumData.xml");
    let album_data =
        Value::from_file(library_path.as_path()).expect("failed to read AlbumData.xml");
    library_path.pop();

    // Read version
    let version = album_data
        .as_dictionary()
        .and_then(|dict| dict.get("Application Version"))
        .and_then(|version| version.as_string());
    println!("Album generated by iPhoto {}", version.unwrap());

    // Read the archive path so that we can strip it from the image paths in the archive
    let archive_path = album_data
        .as_dictionary()
        .and_then(|dict| dict.get("Archive Path"))
        .and_then(|path| path.as_string())
        .unwrap();

    // Parse masters entry
    let masters: HashMap<u32, Master> = album_data
        .as_dictionary()
        .and_then(|dict| dict.get("Master Image List"))
        .map(|masters| masters_from_value(masters, &archive_path, library_path.as_path()))
        .unwrap();

    // Parse albums entry
    let albums: Vec<Album> = album_data
        .as_dictionary()
        .and_then(|dict| dict.get("List of Albums"))
        .map(|album| albums_from_value(album))
        .unwrap();

    // let's copy some pictures
    for album in albums {
        // create album directory
        output_path.push(&album.album_name);
        println!(
            "processing album \"{}\" -> \"{}\"",
            &album.album_name,
            output_path.to_str().unwrap()
        );
        match fs::create_dir(output_path.as_path()) {
            Err(error) => {
                if let Some(raw_os_err) = error.raw_os_error() {
                    if raw_os_err != 17 {
                        println!("error: failed to create album directory: {}", error);
                        output_path.pop();
                        continue;
                    }
                } else {
                    output_path.pop();
                    continue;
                }
            }
            _ => {}
        }

        // keep track of the most current file time to set the modification time of the album
        // directory
        let mut last_image_timestamp: FileTime = FileTime::zero();
        for key in album.images {
            if let Some(image) = masters.get(&key) {
                output_path.push(image.path.file_name().unwrap());
                match fs::copy(&image.path, &output_path) {
                    Err(error) => println!(
                        "failed to copy {} -> {}: {}",
                        image.path.display(),
                        output_path.display(),
                        error
                    ),
                    Ok(_) => {
                        println!(
                            "copied: {} -> {}",
                            image.path.display(),
                            output_path.display()
                        );
                        last_image_timestamp = std::cmp::max(last_image_timestamp, image.timestamp);
                        let _ =
                            set_file_times(output_path.as_path(), image.timestamp, image.timestamp);
                    }
                }
                output_path.pop();
            }
        }
        let _ = set_file_times(
            output_path.as_path(),
            last_image_timestamp,
            last_image_timestamp,
        );
        output_path.pop();
    }
    Ok(())
}
