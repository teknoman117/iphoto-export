/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */

use clap::{App, Arg};
use filetime::{set_file_times, FileTime};
use std::fs;
use std::path::PathBuf;

mod iphoto_structs;

use crate::iphoto_structs::Library;

fn main() -> Result<(), std::io::Error> {
    // Parse command line options
    let matches = App::new("iphoto-extract")
        .version(env!("CARGO_PKG_VERSION"))
        .author(env!("CARGO_PKG_AUTHORS"))
        .about("Converts an Apple iPhoto library into an album directory structure")
        .arg(
            Arg::with_name("library-path")
                .short("l")
                .long("library-path")
                .value_name("LIBRARY")
                .help("Path to the iPhoto Library")
                .takes_value(true),
        )
        .arg(
            Arg::with_name("output-path")
                .short("o")
                .long("output-path")
                .value_name("OUTPUT")
                .help("Path where the extracted albums will be placed")
                .takes_value(true),
        )
        .get_matches();

    // Read Library plist structure
    let library_path = match matches.value_of("library-path") {
        Some(path) => PathBuf::from(path),
        None => std::env::current_dir().unwrap(),
    };

    let library: Library = plist::from_file(library_path.join("AlbumData.xml"))
        .expect("failed to parse AlbumData.xml");

    // Create the output directory
    let mut output_path = PathBuf::from(matches.value_of("output-path").unwrap_or("extract"));
    fs::create_dir(output_path.as_path())?;

    println!("Album generated by iPhoto {}", library.application_version);

    // let's copy some pictures
    for album in library.albums {
        // create album directory
        output_path.push(&album.name);
        println!(
            "processing album \"{}\" -> \"{}\"",
            &album.name,
            output_path.to_str().unwrap()
        );
        match fs::create_dir(output_path.as_path()) {
            Err(error) => {
                if let Some(raw_os_err) = error.raw_os_error() {
                    if raw_os_err != 17 {
                        println!("error: failed to create album directory: {}", error);
                        output_path.pop();
                        continue;
                    }
                } else {
                    output_path.pop();
                    continue;
                }
            }
            _ => {}
        }

        // keep track of the most current file time to set the modification time of the album
        // directory
        let mut last_image_date: FileTime = FileTime::zero();
        for key in album.images {
            if let Some(image) = library.master_images.get(&key) {
                let image_path =
                    library_path.join(image.path.strip_prefix(&library.archive_path).unwrap());
                output_path.push(image.path.file_name().unwrap());
                match fs::copy(&image_path, &output_path) {
                    Err(error) => println!(
                        "failed to copy {} -> {}: {}",
                        image_path.display(),
                        output_path.display(),
                        error
                    ),
                    Ok(_) => {
                        println!(
                            "copied: {} -> {}",
                            image_path.display(),
                            output_path.display()
                        );
                        last_image_date = std::cmp::max(last_image_date, image.creation_date);
                        let _ = set_file_times(
                            output_path.as_path(),
                            image.creation_date,
                            image.creation_date,
                        );
                    }
                }
                output_path.pop();
            }
        }
        let _ = set_file_times(output_path.as_path(), last_image_date, last_image_date);
        output_path.pop();
    }
    Ok(())
}
