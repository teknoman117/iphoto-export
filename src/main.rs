/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */

use clap::{App, Arg};
use filetime::{set_file_times, FileTime};
use plist::Value;

use std::collections::HashMap;
use std::fs;
use std::path::PathBuf;

struct Album {
    album_name: String,
    images: Vec<u32>,
}

struct Master {
    path: PathBuf,
    timestamp: FileTime,
}

fn album_from_value<'a>(value: &'a plist::Value) -> Album {
    let dict = value.as_dictionary().unwrap();
    Album {
        album_name: dict
            .get("AlbumName")
            .unwrap()
            .as_string()
            .unwrap()
            .replace("/", "")
            .trim()
            .to_string(),
        images: dict
            .get("KeyList")
            .unwrap()
            .as_array()
            .unwrap()
            .into_iter()
            .map(|key| key.as_string().unwrap().to_string().parse::<u32>().unwrap())
            .collect(),
    }
}

// I would use serde_derive to deserialize the archive, but Apple doesn't stick to the same
// key naming convention and I'm not sure how to get serde to deal with that.
fn main() -> Result<(), std::io::Error> {
    // Parse command line options
    let matches = App::new("iphoto-extract")
        .version(env!("CARGO_PKG_VERSION"))
        .author(env!("CARGO_PKG_AUTHORS"))
        .about("Converts an Apple iPhoto library into an album directory structure")
        .arg(
            Arg::with_name("library-path")
                .short("l")
                .long("library-path")
                .value_name("LIBRARY")
                .help("Path to the iPhoto Library")
                .takes_value(true),
        )
        .arg(
            Arg::with_name("output-path")
                .short("o")
                .long("output-path")
                .value_name("OUTPUT")
                .help("Path where the extracted albums will be placed")
                .takes_value(true),
        )
        .get_matches();

    // Create the output directory
    let mut output_path = PathBuf::from(matches.value_of("output-path").unwrap_or("extract"));
    fs::create_dir(output_path.as_path())?;

    // Read Library plist structure
    let mut library_path = match matches.value_of("library-path") {
        Some(path) => PathBuf::from(path),
        None => std::env::current_dir().unwrap(),
    };

    library_path.push("AlbumData.xml");
    let album_data =
        Value::from_file(library_path.as_path()).expect("failed to read AlbumData.xml");
    library_path.pop();

    // Read version
    let version = album_data
        .as_dictionary()
        .and_then(|dict| dict.get("Application Version"))
        .and_then(|version| version.as_string());
    println!("Album generated by iPhoto {}", version.unwrap());

    // Read the archive path so that we can strip it from the image paths in the archive
    let archive_path = album_data
        .as_dictionary()
        .and_then(|dict| dict.get("Archive Path"))
        .and_then(|path| path.as_string())
        .unwrap();

    // Parse the master images structure
    let masters = {
        let mut masters = HashMap::new();
        let data = album_data
            .as_dictionary()
            .and_then(|dict| dict.get("Master Image List"))
            .and_then(|masters| masters.as_dictionary())
            .unwrap();
        for (key, value) in data.into_iter() {
            let index = key.to_string().parse::<u32>().unwrap();
            let path = value
                .as_dictionary()
                .and_then(|dict| dict.get("ImagePath"))
                .and_then(|path| path.as_string())
                .map(|path| path.replace(archive_path, "."))
                .map(|rpath| library_path.join(rpath))
                .unwrap();
            let timestamp = value
                .as_dictionary()
                .and_then(|dict| dict.get("DateAsTimerIntervalGMT"))
                .and_then(|interval| interval.as_real())
                .unwrap();
            // Apple CoreData's epoch is not the Unix epoch
            let adjusted_time = FileTime::from_unix_time((timestamp + 978307200.0) as i64, 0);
            masters.insert(
                index,
                Master {
                    path: path,
                    timestamp: adjusted_time,
                },
            );
        }
        masters
    };

    // dump albums
    let albums: Vec<Album> = album_data
        .as_dictionary()
        .and_then(|dict| dict.get("List of Albums"))
        .and_then(|albums| albums.as_array())
        .unwrap()
        .into_iter()
        .map(|album| album_from_value(album))
        .collect();
    // let's copy some pictures

    for album in albums {
        // create album directory
        output_path.push(&album.album_name);
        println!(
            "processing album \"{}\" -> \"{}\"",
            &album.album_name,
            output_path.to_str().unwrap()
        );
        match fs::create_dir(output_path.as_path()) {
            Err(error) => {
                if let Some(raw_os_err) = error.raw_os_error() {
                    if raw_os_err != 17 {
                        println!("error: failed to create album directory: {}", error);
                        output_path.pop();
                        continue;
                    }
                } else {
                    output_path.pop();
                    continue;
                }
            }
            _ => {}
        }

        // keep track of the most current file time to set the modification time of the album
        // directory
        let mut last_image_timestamp: FileTime = FileTime::zero();
        for key in album.images {
            if let Some(image) = masters.get(&key) {
                output_path.push(image.path.file_name().unwrap());
                match fs::copy(&image.path, &output_path) {
                    Err(error) => println!(
                        "failed to copy {} -> {}: {}",
                        image.path.display(),
                        output_path.display(),
                        error
                    ),
                    Ok(_) => {
                        println!(
                            "copied: {} -> {}",
                            image.path.display(),
                            output_path.display()
                        );
                        last_image_timestamp = std::cmp::max(last_image_timestamp, image.timestamp);
                        let _ =
                            set_file_times(output_path.as_path(), image.timestamp, image.timestamp);
                    }
                }
                output_path.pop();
            }
        }
        let _ = set_file_times(
            output_path.as_path(),
            last_image_timestamp,
            last_image_timestamp,
        );
        output_path.pop();
    }
    Ok(())
}
